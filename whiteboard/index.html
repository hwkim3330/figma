<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whiteboard - DesignFlow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #fafafa;
            --surface: #ffffff;
            --border: #e5e5e5;
            --text: #1a1a1a;
            --text-dim: #666666;
            --accent: #2563eb;
            --accent-light: #3b82f6;
            --red: #ef4444;
            --yellow: #eab308;
            --green: #22c55e;
            --blue: #3b82f6;
            --purple: #8b5cf6;
            --pink: #ec4899;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        /* Floating Toolbar */
        .toolbar {
            position: fixed;
            left: 50%;
            bottom: 24px;
            transform: translateX(-50%);
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            z-index: 100;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            border: none;
            background: transparent;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            position: relative;
        }

        .tool-btn:hover { background: var(--bg); }
        .tool-btn.active { background: var(--accent); }
        .tool-btn svg { width: 22px; height: 22px; stroke: var(--text); stroke-width: 2; fill: none; }
        .tool-btn.active svg { stroke: white; }

        .tool-btn[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 52px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--text);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
        }

        .separator {
            width: 1px;
            height: 32px;
            background: var(--border);
            margin: 0 8px;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border: 2px solid var(--border);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .color-btn:hover { transform: scale(1.15); }
        .color-btn.active { border-color: var(--text); border-width: 3px; }

        .stroke-select {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px;
            background: var(--bg);
            border-radius: 8px;
        }

        .stroke-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stroke-btn:hover { background: var(--border); }
        .stroke-btn.active { background: var(--accent); }
        .stroke-btn.active .stroke-line { background: white; }

        .stroke-line {
            background: var(--text);
            border-radius: 2px;
        }

        /* Canvas */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            cursor: crosshair;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Top Controls */
        .top-bar {
            position: fixed;
            top: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 100;
        }

        .top-bar > * { pointer-events: auto; }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: all 0.2s;
        }

        .back-btn:hover { border-color: var(--accent); }

        .top-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            transition: all 0.2s;
        }

        .action-btn:hover { border-color: var(--accent); }

        .action-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .action-btn.primary:hover { background: var(--accent-light); }

        .action-btn svg { width: 18px; height: 18px; stroke: currentColor; stroke-width: 2; fill: none; }

        /* Zoom Controls */
        .zoom-controls {
            position: fixed;
            bottom: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            z-index: 100;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover { background: var(--bg); }
        .zoom-btn svg { width: 18px; height: 18px; stroke: var(--text); stroke-width: 2; fill: none; }

        .zoom-display {
            font-size: 11px;
            text-align: center;
            color: var(--text-dim);
            padding: 4px;
        }

        /* Sticky Notes */
        .sticky-note {
            position: absolute;
            min-width: 200px;
            min-height: 150px;
            padding: 16px;
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            cursor: move;
            font-size: 14px;
            line-height: 1.5;
        }

        .sticky-note.yellow { background: #fef08a; }
        .sticky-note.blue { background: #93c5fd; }
        .sticky-note.green { background: #86efac; }
        .sticky-note.pink { background: #f9a8d4; }
        .sticky-note.purple { background: #c4b5fd; }

        .sticky-note textarea {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            resize: none;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
            outline: none;
        }

        .sticky-note .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(0,0,0,0.1);
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 14px;
        }

        .sticky-note:hover .delete-btn { opacity: 1; }

        /* Text Box */
        .text-box {
            position: absolute;
            min-width: 100px;
            padding: 8px 12px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            background: white;
            font-size: 16px;
            outline: none;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(60px);
            background: var(--text);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Shape Preview */
        .shape-preview {
            position: absolute;
            pointer-events: none;
            border: 2px dashed var(--accent);
            background: rgba(37, 99, 235, 0.1);
        }
    </style>
</head>
<body>
    <div class="canvas-container" id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="top-bar">
        <a href="../index.html" class="back-btn">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            Home
        </a>
        <div class="top-actions">
            <button class="action-btn" id="undo-btn">
                <svg viewBox="0 0 24 24"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/></svg>
                Undo
            </button>
            <button class="action-btn" id="clear-btn">
                <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                Clear
            </button>
            <button class="action-btn primary" id="export-btn">
                <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                Export
            </button>
        </div>
    </div>

    <div class="toolbar">
        <button class="tool-btn active" data-tool="pen" data-tooltip="Pen (P)">
            <svg viewBox="0 0 24 24"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
        </button>
        <button class="tool-btn" data-tool="highlighter" data-tooltip="Highlighter (H)">
            <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
        </button>
        <button class="tool-btn" data-tool="eraser" data-tooltip="Eraser (E)">
            <svg viewBox="0 0 24 24"><path d="M20 20H7L3 16l9-9 8 8-4 4"/><path d="M6 11l6 6"/></svg>
        </button>

        <div class="separator"></div>

        <button class="tool-btn" data-tool="select" data-tooltip="Select (V)">
            <svg viewBox="0 0 24 24"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></svg>
        </button>
        <button class="tool-btn" data-tool="rectangle" data-tooltip="Rectangle (R)">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
        </button>
        <button class="tool-btn" data-tool="circle" data-tooltip="Circle (C)">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>
        </button>
        <button class="tool-btn" data-tool="arrow" data-tooltip="Arrow (A)">
            <svg viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
        </button>
        <button class="tool-btn" data-tool="line" data-tooltip="Line (L)">
            <svg viewBox="0 0 24 24"><line x1="5" y1="19" x2="19" y2="5"/></svg>
        </button>

        <div class="separator"></div>

        <button class="tool-btn" data-tool="text" data-tooltip="Text (T)">
            <svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
        </button>
        <button class="tool-btn" data-tool="sticky" data-tooltip="Sticky Note (S)">
            <svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
        </button>

        <div class="separator"></div>

        <button class="color-btn active" data-color="#1a1a1a" style="background: #1a1a1a;"></button>
        <button class="color-btn" data-color="#ef4444" style="background: #ef4444;"></button>
        <button class="color-btn" data-color="#22c55e" style="background: #22c55e;"></button>
        <button class="color-btn" data-color="#3b82f6" style="background: #3b82f6;"></button>
        <button class="color-btn" data-color="#8b5cf6" style="background: #8b5cf6;"></button>

        <div class="separator"></div>

        <div class="stroke-select">
            <button class="stroke-btn active" data-width="3">
                <div class="stroke-line" style="width: 16px; height: 2px;"></div>
            </button>
            <button class="stroke-btn" data-width="6">
                <div class="stroke-line" style="width: 16px; height: 4px;"></div>
            </button>
            <button class="stroke-btn" data-width="10">
                <div class="stroke-line" style="width: 16px; height: 6px;"></div>
            </button>
        </div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" id="zoom-in">
            <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
        </button>
        <div class="zoom-display" id="zoom-display">100%</div>
        <button class="zoom-btn" id="zoom-out">
            <svg viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"/></svg>
        </button>
        <button class="zoom-btn" id="zoom-reset">
            <svg viewBox="0 0 24 24"><path d="M3 12a9 9 0 109-9 9.75 9.75 0 00-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        </button>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // State
        const state = {
            tool: 'pen',
            color: '#1a1a1a',
            strokeWidth: 3,
            zoom: 1,
            panX: 0,
            panY: 0,
            isDrawing: false,
            isPanning: false,
            startX: 0,
            startY: 0,
            paths: [],
            currentPath: null,
            shapes: [],
            stickyNotes: [],
            history: [],
            historyIndex: -1
        };

        // Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const toast = document.getElementById('toast');

        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupEventListeners();
            render();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render();
        }

        // Event Listeners
        function setupEventListeners() {
            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => setTool(btn.dataset.tool));
            });

            // Color buttons
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => setColor(btn.dataset.color));
            });

            // Stroke buttons
            document.querySelectorAll('.stroke-btn').forEach(btn => {
                btn.addEventListener('click', () => setStrokeWidth(parseInt(btn.dataset.width)));
            });

            // Canvas events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });

            // Touch support
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);

            // Buttons
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('clear-btn').addEventListener('click', clearCanvas);
            document.getElementById('export-btn').addEventListener('click', exportCanvas);
            document.getElementById('zoom-in').addEventListener('click', () => zoom(0.1));
            document.getElementById('zoom-out').addEventListener('click', () => zoom(-0.1));
            document.getElementById('zoom-reset').addEventListener('click', resetZoom);

            // Keyboard
            document.addEventListener('keydown', handleKeyDown);
        }

        function setTool(tool) {
            state.tool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            canvas.style.cursor = tool === 'select' ? 'default' : 'crosshair';
        }

        function setColor(color) {
            state.color = color;
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === color);
            });
        }

        function setStrokeWidth(width) {
            state.strokeWidth = width;
            document.querySelectorAll('.stroke-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.width) === width);
            });
        }

        // Mouse Handlers
        function handleMouseDown(e) {
            if (e.button === 1 || (e.button === 0 && e.altKey)) {
                state.isPanning = true;
                state.startX = e.clientX - state.panX;
                state.startY = e.clientY - state.panY;
                canvas.style.cursor = 'grabbing';
                return;
            }

            const x = (e.clientX - state.panX) / state.zoom;
            const y = (e.clientY - state.panY) / state.zoom;

            state.isDrawing = true;
            state.startX = x;
            state.startY = y;

            if (state.tool === 'pen' || state.tool === 'highlighter') {
                state.currentPath = {
                    type: state.tool,
                    color: state.color,
                    width: state.strokeWidth,
                    opacity: state.tool === 'highlighter' ? 0.4 : 1,
                    points: [{ x, y }]
                };
            } else if (state.tool === 'sticky') {
                createStickyNote(e.clientX, e.clientY);
                state.isDrawing = false;
            } else if (state.tool === 'text') {
                createTextBox(e.clientX, e.clientY);
                state.isDrawing = false;
            }
        }

        function handleMouseMove(e) {
            if (state.isPanning) {
                state.panX = e.clientX - state.startX;
                state.panY = e.clientY - state.startY;
                render();
                return;
            }

            if (!state.isDrawing) return;

            const x = (e.clientX - state.panX) / state.zoom;
            const y = (e.clientY - state.panY) / state.zoom;

            if (state.tool === 'pen' || state.tool === 'highlighter') {
                state.currentPath.points.push({ x, y });
                render();
                drawPath(state.currentPath);
            } else if (state.tool === 'eraser') {
                eraseAt(x, y);
            } else if (['rectangle', 'circle', 'arrow', 'line'].includes(state.tool)) {
                render();
                drawShapePreview(x, y);
            }
        }

        function handleMouseUp(e) {
            if (state.isPanning) {
                state.isPanning = false;
                canvas.style.cursor = state.tool === 'select' ? 'default' : 'crosshair';
                return;
            }

            if (!state.isDrawing) return;

            const x = (e.clientX - state.panX) / state.zoom;
            const y = (e.clientY - state.panY) / state.zoom;

            if (state.tool === 'pen' || state.tool === 'highlighter') {
                if (state.currentPath && state.currentPath.points.length > 1) {
                    state.paths.push(state.currentPath);
                    saveHistory();
                }
                state.currentPath = null;
            } else if (['rectangle', 'circle', 'arrow', 'line'].includes(state.tool)) {
                const shape = {
                    type: state.tool,
                    x1: state.startX,
                    y1: state.startY,
                    x2: x,
                    y2: y,
                    color: state.color,
                    width: state.strokeWidth
                };
                state.shapes.push(shape);
                saveHistory();
            }

            state.isDrawing = false;
            render();
        }

        // Touch Handlers
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY, button: 0 });
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
        }

        function handleTouchEnd(e) {
            handleMouseUp({ clientX: state.startX * state.zoom + state.panX, clientY: state.startY * state.zoom + state.panY });
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoom(delta, e.clientX, e.clientY);
        }

        function handleKeyDown(e) {
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

            switch (e.key.toLowerCase()) {
                case 'p': setTool('pen'); break;
                case 'h': setTool('highlighter'); break;
                case 'e': setTool('eraser'); break;
                case 'v': setTool('select'); break;
                case 'r': setTool('rectangle'); break;
                case 'c': setTool('circle'); break;
                case 'a': setTool('arrow'); break;
                case 'l': setTool('line'); break;
                case 't': setTool('text'); break;
                case 's': setTool('sticky'); break;
                case 'z':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        undo();
                    }
                    break;
            }

            if (e.key === '+' || e.key === '=') zoom(0.1);
            if (e.key === '-') zoom(-0.1);
        }

        // Rendering
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);

            // Draw grid
            drawGrid();

            // Draw paths
            state.paths.forEach(path => drawPath(path));

            // Draw shapes
            state.shapes.forEach(shape => drawShape(shape));

            ctx.restore();
        }

        function drawGrid() {
            const gridSize = 40;
            ctx.strokeStyle = '#e5e5e5';
            ctx.lineWidth = 0.5 / state.zoom;

            const startX = Math.floor(-state.panX / state.zoom / gridSize) * gridSize;
            const startY = Math.floor(-state.panY / state.zoom / gridSize) * gridSize;
            const endX = startX + canvas.width / state.zoom + gridSize * 2;
            const endY = startY + canvas.height / state.zoom + gridSize * 2;

            ctx.beginPath();
            for (let x = startX; x < endX; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }
            for (let y = startY; y < endY; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }
            ctx.stroke();
        }

        function drawPath(path) {
            if (path.points.length < 2) return;

            ctx.save();
            ctx.strokeStyle = path.color;
            ctx.lineWidth = path.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalAlpha = path.opacity;

            ctx.beginPath();
            ctx.moveTo(path.points[0].x, path.points[0].y);

            for (let i = 1; i < path.points.length; i++) {
                const prev = path.points[i - 1];
                const curr = path.points[i];
                const midX = (prev.x + curr.x) / 2;
                const midY = (prev.y + curr.y) / 2;
                ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
            }

            ctx.stroke();
            ctx.restore();
        }

        function drawShape(shape) {
            ctx.strokeStyle = shape.color;
            ctx.lineWidth = shape.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            switch (shape.type) {
                case 'rectangle':
                    ctx.strokeRect(
                        Math.min(shape.x1, shape.x2),
                        Math.min(shape.y1, shape.y2),
                        Math.abs(shape.x2 - shape.x1),
                        Math.abs(shape.y2 - shape.y1)
                    );
                    break;

                case 'circle':
                    const rx = Math.abs(shape.x2 - shape.x1) / 2;
                    const ry = Math.abs(shape.y2 - shape.y1) / 2;
                    const cx = (shape.x1 + shape.x2) / 2;
                    const cy = (shape.y1 + shape.y2) / 2;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    break;

                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(shape.x1, shape.y1);
                    ctx.lineTo(shape.x2, shape.y2);
                    ctx.stroke();
                    break;

                case 'arrow':
                    ctx.beginPath();
                    ctx.moveTo(shape.x1, shape.y1);
                    ctx.lineTo(shape.x2, shape.y2);
                    ctx.stroke();

                    // Arrow head
                    const angle = Math.atan2(shape.y2 - shape.y1, shape.x2 - shape.x1);
                    const headLen = 15;
                    ctx.beginPath();
                    ctx.moveTo(shape.x2, shape.y2);
                    ctx.lineTo(
                        shape.x2 - headLen * Math.cos(angle - Math.PI / 6),
                        shape.y2 - headLen * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.moveTo(shape.x2, shape.y2);
                    ctx.lineTo(
                        shape.x2 - headLen * Math.cos(angle + Math.PI / 6),
                        shape.y2 - headLen * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.stroke();
                    break;
            }
        }

        function drawShapePreview(x, y) {
            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);

            ctx.strokeStyle = state.color;
            ctx.lineWidth = state.strokeWidth;
            ctx.setLineDash([5, 5]);

            drawShape({
                type: state.tool,
                x1: state.startX,
                y1: state.startY,
                x2: x,
                y2: y,
                color: state.color,
                width: state.strokeWidth
            });

            ctx.restore();
        }

        function eraseAt(x, y) {
            const eraseRadius = 20;

            state.paths = state.paths.filter(path => {
                return !path.points.some(point =>
                    Math.hypot(point.x - x, point.y - y) < eraseRadius
                );
            });

            state.shapes = state.shapes.filter(shape => {
                const cx = (shape.x1 + shape.x2) / 2;
                const cy = (shape.y1 + shape.y2) / 2;
                return Math.hypot(cx - x, cy - y) > eraseRadius;
            });

            render();
        }

        // Sticky Notes
        function createStickyNote(x, y) {
            const colors = ['yellow', 'blue', 'green', 'pink', 'purple'];
            const colorClass = colors[Math.floor(Math.random() * colors.length)];

            const note = document.createElement('div');
            note.className = `sticky-note ${colorClass}`;
            note.style.left = x + 'px';
            note.style.top = y + 'px';

            const textarea = document.createElement('textarea');
            textarea.placeholder = 'Type here...';
            note.appendChild(textarea);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = 'Ã—';
            deleteBtn.onclick = () => note.remove();
            note.appendChild(deleteBtn);

            // Drag functionality
            let isDragging = false;
            let offsetX, offsetY;

            note.addEventListener('mousedown', (e) => {
                if (e.target === textarea || e.target === deleteBtn) return;
                isDragging = true;
                offsetX = e.clientX - note.offsetLeft;
                offsetY = e.clientY - note.offsetTop;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                note.style.left = (e.clientX - offsetX) + 'px';
                note.style.top = (e.clientY - offsetY) + 'px';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            container.appendChild(note);
            textarea.focus();
        }

        // Text Box
        function createTextBox(x, y) {
            const input = document.createElement('div');
            input.className = 'text-box';
            input.contentEditable = true;
            input.style.left = x + 'px';
            input.style.top = y + 'px';

            input.addEventListener('blur', () => {
                if (!input.textContent.trim()) {
                    input.remove();
                } else {
                    input.style.border = 'none';
                }
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    input.blur();
                }
            });

            container.appendChild(input);
            input.focus();
        }

        // Zoom
        function zoom(delta, centerX = canvas.width / 2, centerY = canvas.height / 2) {
            const prevZoom = state.zoom;
            state.zoom = Math.max(0.25, Math.min(3, state.zoom + delta));

            // Zoom towards cursor
            const zoomRatio = state.zoom / prevZoom;
            state.panX = centerX - (centerX - state.panX) * zoomRatio;
            state.panY = centerY - (centerY - state.panY) * zoomRatio;

            document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
            render();
        }

        function resetZoom() {
            state.zoom = 1;
            state.panX = 0;
            state.panY = 0;
            document.getElementById('zoom-display').textContent = '100%';
            render();
        }

        // History
        function saveHistory() {
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push({
                paths: JSON.parse(JSON.stringify(state.paths)),
                shapes: JSON.parse(JSON.stringify(state.shapes))
            });
            state.historyIndex++;
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                const snapshot = state.history[state.historyIndex];
                state.paths = JSON.parse(JSON.stringify(snapshot.paths));
                state.shapes = JSON.parse(JSON.stringify(snapshot.shapes));
                render();
                showToast('Undo');
            } else if (state.paths.length > 0 || state.shapes.length > 0) {
                state.paths = [];
                state.shapes = [];
                render();
                showToast('Undo');
            }
        }

        // Actions
        function clearCanvas() {
            if (state.paths.length === 0 && state.shapes.length === 0) return;

            saveHistory();
            state.paths = [];
            state.shapes = [];

            // Remove sticky notes and text boxes
            document.querySelectorAll('.sticky-note, .text-box').forEach(el => el.remove());

            render();
            showToast('Canvas cleared');
        }

        function exportCanvas() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // Find bounds
            let minX = 0, minY = 0, maxX = canvas.width, maxY = canvas.height;

            state.paths.forEach(path => {
                path.points.forEach(p => {
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                });
            });

            const padding = 50;
            tempCanvas.width = maxX - minX + padding * 2;
            tempCanvas.height = maxY - minY + padding * 2;

            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            tempCtx.translate(-minX + padding, -minY + padding);

            state.paths.forEach(path => {
                tempCtx.strokeStyle = path.color;
                tempCtx.lineWidth = path.width;
                tempCtx.lineCap = 'round';
                tempCtx.lineJoin = 'round';
                tempCtx.globalAlpha = path.opacity;

                tempCtx.beginPath();
                tempCtx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    const prev = path.points[i - 1];
                    const curr = path.points[i];
                    const midX = (prev.x + curr.x) / 2;
                    const midY = (prev.y + curr.y) / 2;
                    tempCtx.quadraticCurveTo(prev.x, prev.y, midX, midY);
                }
                tempCtx.stroke();
                tempCtx.globalAlpha = 1;
            });

            state.shapes.forEach(shape => {
                tempCtx.strokeStyle = shape.color;
                tempCtx.lineWidth = shape.width;
                tempCtx.lineCap = 'round';
                tempCtx.lineJoin = 'round';

                switch (shape.type) {
                    case 'rectangle':
                        tempCtx.strokeRect(
                            Math.min(shape.x1, shape.x2),
                            Math.min(shape.y1, shape.y2),
                            Math.abs(shape.x2 - shape.x1),
                            Math.abs(shape.y2 - shape.y1)
                        );
                        break;
                    case 'circle':
                        const rx = Math.abs(shape.x2 - shape.x1) / 2;
                        const ry = Math.abs(shape.y2 - shape.y1) / 2;
                        const cx = (shape.x1 + shape.x2) / 2;
                        const cy = (shape.y1 + shape.y2) / 2;
                        tempCtx.beginPath();
                        tempCtx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                        tempCtx.stroke();
                        break;
                    case 'line':
                        tempCtx.beginPath();
                        tempCtx.moveTo(shape.x1, shape.y1);
                        tempCtx.lineTo(shape.x2, shape.y2);
                        tempCtx.stroke();
                        break;
                    case 'arrow':
                        tempCtx.beginPath();
                        tempCtx.moveTo(shape.x1, shape.y1);
                        tempCtx.lineTo(shape.x2, shape.y2);
                        tempCtx.stroke();
                        const angle = Math.atan2(shape.y2 - shape.y1, shape.x2 - shape.x1);
                        const headLen = 15;
                        tempCtx.beginPath();
                        tempCtx.moveTo(shape.x2, shape.y2);
                        tempCtx.lineTo(shape.x2 - headLen * Math.cos(angle - Math.PI / 6), shape.y2 - headLen * Math.sin(angle - Math.PI / 6));
                        tempCtx.moveTo(shape.x2, shape.y2);
                        tempCtx.lineTo(shape.x2 - headLen * Math.cos(angle + Math.PI / 6), shape.y2 - headLen * Math.sin(angle + Math.PI / 6));
                        tempCtx.stroke();
                        break;
                }
            });

            const link = document.createElement('a');
            link.download = 'whiteboard.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();

            showToast('Exported as PNG');
        }

        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'TEXTAREA') return;

            const shortcuts = {
                'p': 'pen', 'h': 'highlighter', 'e': 'eraser', 'v': 'select',
                't': 'text', 's': 'sticky', 'r': 'rectangle', 'c': 'circle',
                'a': 'arrow', 'l': 'line'
            };

            if (!e.ctrlKey && !e.metaKey && shortcuts[e.key.toLowerCase()]) {
                setTool(shortcuts[e.key.toLowerCase()]);
            }

            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                openHelpModal();
            }

            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            }

            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault();
                saveToLocalStorage();
            }

            if (e.key === '=' || e.key === '+') zoomIn();
            if (e.key === '-') zoomOut();
        });

        // Save/Load
        function saveToLocalStorage() {
            const data = { paths, stickyNotes: getStickyNotesData(), zoom: state.zoom, panX: state.panX, panY: state.panY };
            localStorage.setItem('designflow-whiteboard', JSON.stringify(data));
            showToast('Saved!');
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('designflow-whiteboard');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.paths) paths.push(...data.paths);
                    if (data.zoom) state.zoom = data.zoom;
                    if (data.panX) state.panX = data.panX;
                    if (data.panY) state.panY = data.panY;
                    render();
                } catch (e) {}
            }
        }

        function getStickyNotesData() {
            return Array.from(document.querySelectorAll('.sticky-note')).map(note => ({
                x: note.style.left, y: note.style.top, color: note.className.split(' ')[1],
                text: note.querySelector('textarea')?.value || ''
            }));
        }

        // Help Modal
        function openHelpModal() {
            const modal = document.createElement('div');
            modal.id = 'help-modal';
            modal.innerHTML = `
                <div style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:1000;display:flex;align-items:center;justify-content:center;">
                    <div style="background:white;border-radius:16px;padding:24px;max-width:400px;width:90%;">
                        <h2 style="margin-bottom:16px;font-size:18px;">Keyboard Shortcuts</h2>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:13px;">
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">P</kbd> Pen</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">H</kbd> Highlighter</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">E</kbd> Eraser</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">V</kbd> Select</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">T</kbd> Text</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">S</kbd> Sticky</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">R</kbd> Rectangle</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">C</kbd> Circle</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">Ctrl+Z</kbd> Undo</div>
                            <div><kbd style="background:#f3f4f6;padding:2px 8px;border-radius:4px;">Ctrl+S</kbd> Save</div>
                        </div>
                        <button onclick="this.parentElement.parentElement.remove()" style="margin-top:20px;width:100%;padding:10px;background:#2563eb;color:white;border:none;border-radius:8px;cursor:pointer;">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Initialize
        init();
        loadFromLocalStorage();
        saveHistory();

        // Auto-save
        setInterval(() => { if (paths.length > 0) saveToLocalStorage(); }, 60000);
    </script>
</body>
</html>
