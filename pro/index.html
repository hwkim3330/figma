<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Designer - DesignFlow</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-2: #252525;
            --border: #333333;
            --text: #ffffff;
            --text-dim: #888888;
            --accent: #7c3aed;
            --accent-2: #3b82f6;
            --success: #10b981;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            height: 52px;
            background: linear-gradient(90deg, var(--surface), var(--surface-2));
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .back-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-dim);
            text-decoration: none;
            font-size: 13px;
            padding: 6px 12px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .back-btn:hover { background: var(--border); color: var(--text); }

        .logo {
            font-weight: 600;
            font-size: 18px;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .version {
            font-size: 11px;
            padding: 3px 10px;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            border-radius: 12px;
            color: white;
            font-weight: 500;
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .collab-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .collab-btn:hover { opacity: 0.9; }

        .collab-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--text-dim);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }

        /* Toolbar */
        .toolbar {
            height: 48px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 2px;
        }

        .tool-btn {
            width: 38px;
            height: 38px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            position: relative;
        }

        .tool-btn:hover { background: var(--surface-2); }
        .tool-btn.active { background: var(--accent); }
        .tool-btn svg { width: 20px; height: 20px; stroke: var(--text); stroke-width: 1.5; fill: none; }
        .tool-btn.active svg { stroke: white; }

        .tool-btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface-2);
            color: var(--text);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
        }

        .separator {
            width: 1px;
            height: 28px;
            background: var(--border);
            margin: 0 8px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border: 2px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .color-btn:hover { transform: scale(1.1); }

        .zoom-display {
            font-size: 12px;
            color: var(--text-dim);
            min-width: 45px;
            text-align: center;
            font-weight: 500;
        }

        .toolbar-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .export-btn {
            padding: 8px 16px;
            background: var(--success);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .export-btn:hover { opacity: 0.9; }

        /* Main Layout */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Left Sidebar */
        .sidebar-left {
            width: 260px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            color: var(--text-dim);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sidebar-tab:hover { color: var(--text); }
        .sidebar-tab.active { color: var(--accent); border-bottom: 2px solid var(--accent); }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .layer-item {
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            transition: all 0.15s;
            margin-bottom: 2px;
        }

        .layer-item:hover { background: var(--surface-2); }
        .layer-item.selected { background: var(--accent); }

        .layer-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .layer-icon svg { width: 14px; height: 14px; stroke: var(--text); }

        .layer-name { flex: 1; }

        /* Canvas */
        .canvas-container {
            flex: 1;
            background: #0a0a0a;
            position: relative;
            overflow: hidden;
        }

        #canvas { position: absolute; cursor: crosshair; }

        /* Right Sidebar */
        .sidebar-right {
            width: 280px;
            background: var(--surface);
            border-left: 1px solid var(--border);
            overflow-y: auto;
        }

        .props-section {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .props-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
        }

        .props-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .props-toggle {
            width: 20px;
            height: 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            color: var(--text-dim);
            font-size: 14px;
        }

        .prop-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .prop-label {
            font-size: 11px;
            color: var(--text-dim);
            width: 20px;
            text-align: center;
        }

        .prop-input {
            flex: 1;
            height: 32px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0 10px;
            font-size: 13px;
            color: var(--text);
            transition: border-color 0.2s;
        }

        .prop-input:focus { outline: none; border-color: var(--accent); }

        .color-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-preview {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: transform 0.15s;
        }

        .color-preview:hover { transform: scale(1.05); }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-label {
            font-size: 11px;
            color: var(--text-dim);
            width: 50px;
        }

        .slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(124, 58, 237, 0.4);
        }

        .slider-value {
            font-size: 11px;
            color: var(--text-dim);
            width: 45px;
            text-align: right;
        }

        /* Gradient Controls */
        .gradient-controls { margin-top: 12px; }

        .gradient-preview {
            height: 40px;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 1px solid var(--border);
        }

        .gradient-stops {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .gradient-stop {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .gradient-stop input[type="color"] {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .gradient-presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .preset-btn {
            width: 32px;
            height: 32px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
        }

        .preset-btn:hover { transform: scale(1.1); border-color: var(--accent); }

        .preset-btn[data-preset="sunset"] { background: linear-gradient(135deg, #f97316, #ec4899); }
        .preset-btn[data-preset="ocean"] { background: linear-gradient(135deg, #06b6d4, #3b82f6); }
        .preset-btn[data-preset="forest"] { background: linear-gradient(135deg, #22c55e, #14b8a6); }
        .preset-btn[data-preset="fire"] { background: linear-gradient(135deg, #ef4444, #f97316); }
        .preset-btn[data-preset="midnight"] { background: linear-gradient(135deg, #6366f1, #8b5cf6); }
        .preset-btn[data-preset="gold"] { background: linear-gradient(135deg, #eab308, #f59e0b); }

        /* Effects */
        .effect-item {
            padding: 10px;
            background: var(--bg);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .effect-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .effect-name {
            font-size: 12px;
            font-weight: 500;
        }

        .effect-toggle {
            width: 36px;
            height: 20px;
            background: var(--border);
            border-radius: 10px;
            border: none;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .effect-toggle.active { background: var(--accent); }

        .effect-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .effect-toggle.active::after { transform: translateX(16px); }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show { display: flex; }

        .modal-content {
            background: var(--surface);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: var(--border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            color: var(--text);
        }

        .modal-close:hover { background: var(--accent); }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .input-group input {
            width: 100%;
            height: 40px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0 12px;
            font-size: 14px;
            color: var(--text);
        }

        .input-group input:focus { outline: none; border-color: var(--accent); }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 8px;
        }

        .modal-btn:hover { opacity: 0.9; }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface-2);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            font-size: 14px;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .toast.show { transform: translateX(-50%) translateY(0); }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 6px;
            min-width: 200px;
            box-shadow: 0 12px 48px rgba(0,0,0,0.4);
            z-index: 1000;
            display: none;
        }

        .context-menu.show { display: block; }

        .context-item {
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
        }

        .context-item:hover { background: var(--accent); }

        .context-shortcut { color: var(--text-dim); font-size: 11px; }

        .context-separator { height: 1px; background: var(--border); margin: 6px 0; }

        /* Empty State */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-dim);
            pointer-events: none;
        }

        .empty-state svg { width: 80px; height: 80px; stroke: var(--border); margin-bottom: 20px; }
        .empty-state p { font-size: 15px; }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <a href="index.html" class="back-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7"/>
                </svg>
                Home
            </a>
            <span class="logo">Pro Designer</span>
            <span class="version">v2.0</span>
        </div>
        <div class="header-center">
            <div class="collab-status" id="collab-status" style="display: none;">
                <span class="status-dot"></span>
                <span id="peer-count">0 connected</span>
            </div>
        </div>
        <div class="header-right">
            <button class="collab-btn" id="collab-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
                Collaborate
            </button>
            <button class="export-btn" id="export-btn">Export</button>
        </div>
    </div>

    <div class="toolbar">
        <div class="toolbar-group">
            <button class="tool-btn active" data-tool="select" title="Select (V)">
                <svg viewBox="0 0 24 24"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></svg>
            </button>
            <button class="tool-btn" data-tool="rectangle" title="Rectangle (R)">
                <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
            </button>
            <button class="tool-btn" data-tool="circle" title="Circle (C)">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>
            </button>
            <button class="tool-btn" data-tool="triangle" title="Triangle (T)">
                <svg viewBox="0 0 24 24"><path d="M12 3L22 21H2z"/></svg>
            </button>
            <button class="tool-btn" data-tool="line" title="Line (L)">
                <svg viewBox="0 0 24 24"><line x1="5" y1="19" x2="19" y2="5"/></svg>
            </button>
            <button class="tool-btn" data-tool="text" title="Text (X)">
                <svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
            </button>
        </div>

        <div class="separator"></div>

        <div class="toolbar-group">
            <button class="tool-btn" data-tool="pen" title="Pen (P)">
                <svg viewBox="0 0 24 24">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                    <circle cx="11" cy="11" r="2"/>
                </svg>
            </button>
            <button class="tool-btn" data-tool="pencil" title="Pencil (B)">
                <svg viewBox="0 0 24 24"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
            </button>
        </div>

        <div class="separator"></div>

        <div class="toolbar-group">
            <button class="tool-btn" data-tool="star" title="Star (S)">
                <svg viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>
            </button>
            <button class="tool-btn" data-tool="hexagon" title="Hexagon (H)">
                <svg viewBox="0 0 24 24"><path d="M12 2l8 4v12l-8 4-8-4V6z"/></svg>
            </button>
            <button class="tool-btn" data-tool="arrow" title="Arrow (A)">
                <svg viewBox="0 0 24 24"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>
            </button>
        </div>

        <div class="separator"></div>

        <input type="color" class="color-btn" id="fill-color" value="#7c3aed" title="Fill">
        <input type="color" class="color-btn" id="stroke-color" value="#ffffff" title="Stroke">

        <div class="separator"></div>

        <div class="toolbar-group">
            <button class="tool-btn" id="undo-btn" title="Undo (Ctrl+Z)">
                <svg viewBox="0 0 24 24"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/></svg>
            </button>
            <button class="tool-btn" id="redo-btn" title="Redo (Ctrl+Y)">
                <svg viewBox="0 0 24 24"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 019-9 9 9 0 016 2.3l3 2.7"/></svg>
            </button>
        </div>

        <div class="separator"></div>

        <div class="toolbar-group">
            <button class="tool-btn" id="zoom-out" title="Zoom Out (-)">
                <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
            </button>
            <span class="zoom-display" id="zoom-display">100%</span>
            <button class="tool-btn" id="zoom-in" title="Zoom In (+)">
                <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
            </button>
        </div>

        <div class="toolbar-right">
            <button class="tool-btn" id="grid-btn" title="Toggle Grid (G)">
                <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg>
            </button>
            <button class="tool-btn" id="snap-btn" title="Snap to Grid">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="2"/><path d="M12 2v4M12 18v4M2 12h4M18 12h4"/></svg>
            </button>
        </div>
    </div>

    <div class="main-content">
        <div class="sidebar-left">
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" data-tab="layers">Layers</button>
                <button class="sidebar-tab" data-tab="components">Components</button>
            </div>
            <div class="sidebar-content" id="layers-list"></div>
        </div>

        <div class="canvas-container" id="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="empty-state" id="empty-state">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                    <path d="M12 2l10 10-10 10L2 12z"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                <p>Start designing with professional tools</p>
            </div>
        </div>

        <div class="sidebar-right">
            <div class="props-section">
                <div class="props-header">
                    <span class="props-title">Transform</span>
                </div>
                <div class="prop-row">
                    <span class="prop-label">X</span>
                    <input type="number" class="prop-input" id="prop-x" value="0">
                    <span class="prop-label">Y</span>
                    <input type="number" class="prop-input" id="prop-y" value="0">
                </div>
                <div class="prop-row">
                    <span class="prop-label">W</span>
                    <input type="number" class="prop-input" id="prop-w" value="0">
                    <span class="prop-label">H</span>
                    <input type="number" class="prop-input" id="prop-h" value="0">
                </div>
                <div class="slider-row" style="margin-top: 12px;">
                    <span class="slider-label">Rotation</span>
                    <input type="range" class="slider" id="rotation" min="0" max="360" value="0">
                    <span class="slider-value" id="rotation-val">0Â°</span>
                </div>
            </div>

            <div class="props-section">
                <div class="props-header">
                    <span class="props-title">Fill</span>
                </div>
                <div class="color-row">
                    <div class="color-preview" id="fill-preview" style="background: #7c3aed;"></div>
                    <input type="text" class="prop-input" id="fill-hex" value="#7c3aed">
                </div>
                <div class="gradient-controls" id="gradient-controls" style="display: none;">
                    <div class="gradient-preview" id="gradient-preview"></div>
                    <div class="gradient-stops">
                        <div class="gradient-stop">
                            <input type="color" id="grad-color-1" value="#7c3aed">
                            <span style="font-size: 11px; color: var(--text-dim);">0%</span>
                        </div>
                        <div class="gradient-stop">
                            <input type="color" id="grad-color-2" value="#3b82f6">
                            <span style="font-size: 11px; color: var(--text-dim);">100%</span>
                        </div>
                    </div>
                    <div class="gradient-presets">
                        <button class="preset-btn" data-preset="sunset"></button>
                        <button class="preset-btn" data-preset="ocean"></button>
                        <button class="preset-btn" data-preset="forest"></button>
                        <button class="preset-btn" data-preset="fire"></button>
                        <button class="preset-btn" data-preset="midnight"></button>
                        <button class="preset-btn" data-preset="gold"></button>
                    </div>
                </div>
                <div style="margin-top: 12px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="gradient-toggle">
                        <span style="font-size: 12px;">Use Gradient</span>
                    </label>
                </div>
            </div>

            <div class="props-section">
                <div class="props-header">
                    <span class="props-title">Stroke</span>
                </div>
                <div class="color-row">
                    <div class="color-preview" id="stroke-preview" style="background: #ffffff;"></div>
                    <input type="text" class="prop-input" id="stroke-hex" value="#ffffff">
                </div>
                <div class="slider-row" style="margin-top: 12px;">
                    <span class="slider-label">Width</span>
                    <input type="range" class="slider" id="stroke-width" min="0" max="20" value="2">
                    <span class="slider-value" id="stroke-width-val">2px</span>
                </div>
            </div>

            <div class="props-section">
                <div class="props-header">
                    <span class="props-title">Appearance</span>
                </div>
                <div class="slider-row">
                    <span class="slider-label">Opacity</span>
                    <input type="range" class="slider" id="opacity" min="0" max="100" value="100">
                    <span class="slider-value" id="opacity-val">100%</span>
                </div>
                <div class="slider-row" style="margin-top: 12px;">
                    <span class="slider-label">Corner</span>
                    <input type="range" class="slider" id="corner-radius" min="0" max="100" value="0">
                    <span class="slider-value" id="corner-val">0px</span>
                </div>
            </div>

            <div class="props-section">
                <div class="props-header">
                    <span class="props-title">Effects</span>
                </div>
                <div class="effect-item">
                    <div class="effect-header">
                        <span class="effect-name">Drop Shadow</span>
                        <button class="effect-toggle" id="shadow-toggle"></button>
                    </div>
                    <div id="shadow-controls" style="display: none;">
                        <div class="prop-row">
                            <span class="prop-label">X</span>
                            <input type="number" class="prop-input" id="shadow-x" value="0" style="width: 60px;">
                            <span class="prop-label">Y</span>
                            <input type="number" class="prop-input" id="shadow-y" value="4" style="width: 60px;">
                        </div>
                        <div class="slider-row">
                            <span class="slider-label">Blur</span>
                            <input type="range" class="slider" id="shadow-blur" min="0" max="50" value="10">
                            <span class="slider-value" id="shadow-blur-val">10px</span>
                        </div>
                    </div>
                </div>
                <div class="effect-item">
                    <div class="effect-header">
                        <span class="effect-name">Blur</span>
                        <button class="effect-toggle" id="blur-toggle"></button>
                    </div>
                    <div id="blur-controls" style="display: none;">
                        <div class="slider-row">
                            <span class="slider-label">Amount</span>
                            <input type="range" class="slider" id="blur-amount" min="0" max="20" value="5">
                            <span class="slider-value" id="blur-val">5px</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Collaboration Modal -->
    <div class="modal" id="collab-modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Real-time Collaboration</span>
                <button class="modal-close" id="close-modal">&times;</button>
            </div>
            <div class="input-group">
                <label>Your Session ID</label>
                <input type="text" id="my-peer-id" readonly>
            </div>
            <button class="modal-btn" id="copy-id-btn">Copy Session ID</button>
            <div style="text-align: center; margin: 20px 0; color: var(--text-dim);">or</div>
            <div class="input-group">
                <label>Join Session</label>
                <input type="text" id="connect-peer-id" placeholder="Enter session ID to join">
            </div>
            <button class="modal-btn" id="connect-btn">Connect</button>
        </div>
    </div>

    <div class="context-menu" id="context-menu">
        <div class="context-item" data-action="duplicate">Duplicate <span class="context-shortcut">Ctrl+D</span></div>
        <div class="context-item" data-action="copy">Copy <span class="context-shortcut">Ctrl+C</span></div>
        <div class="context-item" data-action="paste">Paste <span class="context-shortcut">Ctrl+V</span></div>
        <div class="context-separator"></div>
        <div class="context-item" data-action="group">Group <span class="context-shortcut">Ctrl+G</span></div>
        <div class="context-item" data-action="ungroup">Ungroup</div>
        <div class="context-separator"></div>
        <div class="context-item" data-action="front">Bring to Front</div>
        <div class="context-item" data-action="back">Send to Back</div>
        <div class="context-separator"></div>
        <div class="context-item" data-action="delete">Delete <span class="context-shortcut">Del</span></div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- Keyboard Shortcuts Modal -->
    <div id="shortcuts-modal" class="modal" style="display: none;">
        <div class="modal-backdrop" onclick="closeModal('shortcuts-modal')"></div>
        <div class="modal-content">
            <div class="modal-header">
                <h2>Keyboard Shortcuts</h2>
                <button class="modal-close" onclick="closeModal('shortcuts-modal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="shortcut-grid">
                    <div class="shortcut-section">
                        <h3>Tools</h3>
                        <div class="shortcut-item"><kbd>V</kbd><span>Select</span></div>
                        <div class="shortcut-item"><kbd>R</kbd><span>Rectangle</span></div>
                        <div class="shortcut-item"><kbd>C</kbd><span>Circle</span></div>
                        <div class="shortcut-item"><kbd>T</kbd><span>Triangle</span></div>
                        <div class="shortcut-item"><kbd>L</kbd><span>Line</span></div>
                        <div class="shortcut-item"><kbd>X</kbd><span>Text</span></div>
                        <div class="shortcut-item"><kbd>S</kbd><span>Star</span></div>
                        <div class="shortcut-item"><kbd>H</kbd><span>Hexagon</span></div>
                        <div class="shortcut-item"><kbd>A</kbd><span>Arrow</span></div>
                        <div class="shortcut-item"><kbd>P</kbd><span>Pen Tool</span></div>
                        <div class="shortcut-item"><kbd>B</kbd><span>Pencil</span></div>
                    </div>
                    <div class="shortcut-section">
                        <h3>Edit</h3>
                        <div class="shortcut-item"><kbd>Ctrl+Z</kbd><span>Undo</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+Y</kbd><span>Redo</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+C</kbd><span>Copy</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+V</kbd><span>Paste</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+D</kbd><span>Duplicate</span></div>
                        <div class="shortcut-item"><kbd>Del</kbd><span>Delete</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+A</kbd><span>Select All</span></div>
                    </div>
                    <div class="shortcut-section">
                        <h3>View</h3>
                        <div class="shortcut-item"><kbd>G</kbd><span>Toggle Grid</span></div>
                        <div class="shortcut-item"><kbd>+</kbd><span>Zoom In</span></div>
                        <div class="shortcut-item"><kbd>-</kbd><span>Zoom Out</span></div>
                        <div class="shortcut-item"><kbd>0</kbd><span>Reset Zoom</span></div>
                        <div class="shortcut-item"><kbd>?</kbd><span>Show Shortcuts</span></div>
                        <div class="shortcut-item"><kbd>Ctrl+S</kbd><span>Save</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <style>
        .modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .modal-backdrop { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); }
        .modal-content { position: relative; background: var(--surface); border-radius: 16px; max-width: 600px; width: 90%; max-height: 80vh; overflow: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 20px 24px; border-bottom: 1px solid var(--border); }
        .modal-header h2 { font-size: 18px; font-weight: 600; }
        .modal-close { width: 32px; height: 32px; border: none; background: var(--surface-2); border-radius: 8px; font-size: 24px; cursor: pointer; color: var(--text-dim); }
        .modal-close:hover { background: var(--border); color: var(--text); }
        .modal-body { padding: 24px; }
        .shortcut-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 24px; }
        .shortcut-section h3 { font-size: 12px; text-transform: uppercase; color: var(--text-dim); margin-bottom: 12px; letter-spacing: 1px; }
        .shortcut-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
        .shortcut-item kbd { background: var(--surface-2); padding: 4px 10px; border-radius: 6px; font-family: monospace; font-size: 12px; color: var(--accent); border: 1px solid var(--border); }
        .shortcut-item span { color: var(--text-dim); font-size: 13px; }
        @media (max-width: 600px) { .shortcut-grid { grid-template-columns: 1fr; } }
    </style>

    <script>
        // ============ Shape Class ============
        class Shape {
            constructor(type, x, y, props = {}) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = props.width || 100;
                this.height = props.height || 100;
                this.fillColor = props.fillColor || '#7c3aed';
                this.strokeColor = props.strokeColor || '#ffffff';
                this.strokeWidth = props.strokeWidth || 2;
                this.opacity = props.opacity || 1;
                this.cornerRadius = props.cornerRadius || 0;
                this.rotation = props.rotation || 0;
                this.text = props.text || 'Text';
                this.fontSize = props.fontSize || 24;
                this.visible = true;
                this.name = type.charAt(0).toUpperCase() + type.slice(1);

                // Gradient
                this.useGradient = props.useGradient || false;
                this.gradientColors = props.gradientColors || ['#7c3aed', '#3b82f6'];
                this.gradientAngle = props.gradientAngle || 135;

                // Effects
                this.shadow = props.shadow || { enabled: false, x: 0, y: 4, blur: 10, color: 'rgba(0,0,0,0.3)' };
                this.blur = props.blur || { enabled: false, amount: 5 };

                // Pen tool points
                this.points = props.points || [];
            }

            draw(ctx) {
                if (!this.visible) return;

                ctx.save();
                ctx.globalAlpha = this.opacity;

                // Apply blur filter
                if (this.blur.enabled) {
                    ctx.filter = `blur(${this.blur.amount}px)`;
                }

                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.rotation * Math.PI / 180);
                ctx.translate(-this.width / 2, -this.height / 2);

                // Apply shadow
                if (this.shadow.enabled) {
                    ctx.shadowOffsetX = this.shadow.x;
                    ctx.shadowOffsetY = this.shadow.y;
                    ctx.shadowBlur = this.shadow.blur;
                    ctx.shadowColor = this.shadow.color;
                }

                // Get fill style (solid or gradient)
                let fillStyle = this.fillColor;
                if (this.useGradient && this.gradientColors.length >= 2) {
                    const angle = this.gradientAngle * Math.PI / 180;
                    const x1 = this.width / 2 - Math.cos(angle) * this.width / 2;
                    const y1 = this.height / 2 - Math.sin(angle) * this.height / 2;
                    const x2 = this.width / 2 + Math.cos(angle) * this.width / 2;
                    const y2 = this.height / 2 + Math.sin(angle) * this.height / 2;
                    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, this.gradientColors[0]);
                    gradient.addColorStop(1, this.gradientColors[1]);
                    fillStyle = gradient;
                }

                switch (this.type) {
                    case 'rectangle': this.drawRoundedRect(ctx, fillStyle); break;
                    case 'circle': this.drawCircle(ctx, fillStyle); break;
                    case 'triangle': this.drawTriangle(ctx, fillStyle); break;
                    case 'line': this.drawLine(ctx); break;
                    case 'text': this.drawText(ctx, fillStyle); break;
                    case 'star': this.drawStar(ctx, fillStyle); break;
                    case 'hexagon': this.drawHexagon(ctx, fillStyle); break;
                    case 'arrow': this.drawArrow(ctx, fillStyle); break;
                    case 'pen': this.drawPath(ctx, fillStyle); break;
                    case 'pencil': this.drawPath(ctx, fillStyle); break;
                }

                ctx.restore();
            }

            drawRoundedRect(ctx, fillStyle) {
                const r = Math.min(this.cornerRadius, this.width / 2, this.height / 2);
                ctx.beginPath();
                ctx.moveTo(r, 0);
                ctx.lineTo(this.width - r, 0);
                ctx.arcTo(this.width, 0, this.width, r, r);
                ctx.lineTo(this.width, this.height - r);
                ctx.arcTo(this.width, this.height, this.width - r, this.height, r);
                ctx.lineTo(r, this.height);
                ctx.arcTo(0, this.height, 0, this.height - r, r);
                ctx.lineTo(0, r);
                ctx.arcTo(0, 0, r, 0, r);
                ctx.closePath();

                ctx.fillStyle = fillStyle;
                ctx.fill();
                if (this.strokeWidth > 0) {
                    ctx.strokeStyle = this.strokeColor;
                    ctx.lineWidth = this.strokeWidth;
                    ctx.stroke();
                }
            }

            drawCircle(ctx, fillStyle) {
                ctx.beginPath();
                ctx.ellipse(this.width / 2, this.height / 2, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
                ctx.fillStyle = fillStyle;
                ctx.fill();
                if (this.strokeWidth > 0) {
                    ctx.strokeStyle = this.strokeColor;
                    ctx.lineWidth = this.strokeWidth;
                    ctx.stroke();
                }
            }

            drawTriangle(ctx, fillStyle) {
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(this.width, this.height);
                ctx.lineTo(0, this.height);
                ctx.closePath();
                ctx.fillStyle = fillStyle;
                ctx.fill();
                if (this.strokeWidth > 0) {
                    ctx.strokeStyle = this.strokeColor;
                    ctx.lineWidth = this.strokeWidth;
                    ctx.stroke();
                }
            }

            drawStar(ctx, fillStyle) {
                const cx = this.width / 2;
                const cy = this.height / 2;
                const outerRadius = Math.min(this.width, this.height) / 2;
                const innerRadius = outerRadius * 0.4;
                const spikes = 5;

                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI / spikes) - Math.PI / 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = fillStyle;
                ctx.fill();
                if (this.strokeWidth > 0) {
                    ctx.strokeStyle = this.strokeColor;
                    ctx.lineWidth = this.strokeWidth;
                    ctx.stroke();
                }
            }

            drawHexagon(ctx, fillStyle) {
                const cx = this.width / 2;
                const cy = this.height / 2;
                const radius = Math.min(this.width, this.height) / 2;

                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI / 3) - Math.PI / 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = fillStyle;
                ctx.fill();
                if (this.strokeWidth > 0) {
                    ctx.strokeStyle = this.strokeColor;
                    ctx.lineWidth = this.strokeWidth;
                    ctx.stroke();
                }
            }

            drawArrow(ctx, fillStyle) {
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(this.width, this.height * 0.4);
                ctx.lineTo(this.width * 0.65, this.height * 0.4);
                ctx.lineTo(this.width * 0.65, this.height);
                ctx.lineTo(this.width * 0.35, this.height);
                ctx.lineTo(this.width * 0.35, this.height * 0.4);
                ctx.lineTo(0, this.height * 0.4);
                ctx.closePath();
                ctx.fillStyle = fillStyle;
                ctx.fill();
                if (this.strokeWidth > 0) {
                    ctx.strokeStyle = this.strokeColor;
                    ctx.lineWidth = this.strokeWidth;
                    ctx.stroke();
                }
            }

            drawLine(ctx) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.width, this.height);
                ctx.strokeStyle = this.strokeColor;
                ctx.lineWidth = this.strokeWidth;
                ctx.stroke();
            }

            drawText(ctx, fillStyle) {
                ctx.font = `${this.fontSize}px Inter, sans-serif`;
                ctx.fillStyle = fillStyle;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.width / 2, this.height / 2);
            }

            drawPath(ctx, fillStyle) {
                if (this.points.length < 2) return;

                ctx.beginPath();
                ctx.moveTo(this.points[0].x - this.x, this.points[0].y - this.y);

                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x - this.x, this.points[i].y - this.y);
                }

                ctx.strokeStyle = this.strokeColor;
                ctx.lineWidth = this.strokeWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            }

            containsPoint(px, py) {
                return px >= this.x && px <= this.x + this.width &&
                       py >= this.y && py <= this.y + this.height;
            }

            clone() {
                const cloned = new Shape(this.type, this.x + 20, this.y + 20, {
                    width: this.width,
                    height: this.height,
                    fillColor: this.fillColor,
                    strokeColor: this.strokeColor,
                    strokeWidth: this.strokeWidth,
                    opacity: this.opacity,
                    cornerRadius: this.cornerRadius,
                    rotation: this.rotation,
                    text: this.text,
                    fontSize: this.fontSize,
                    useGradient: this.useGradient,
                    gradientColors: [...this.gradientColors],
                    gradientAngle: this.gradientAngle,
                    shadow: { ...this.shadow },
                    blur: { ...this.blur },
                    points: this.points.map(p => ({...p}))
                });
                cloned.name = this.name + ' Copy';
                return cloned;
            }

            toJSON() {
                return {
                    id: this.id,
                    type: this.type,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    fillColor: this.fillColor,
                    strokeColor: this.strokeColor,
                    strokeWidth: this.strokeWidth,
                    opacity: this.opacity,
                    cornerRadius: this.cornerRadius,
                    rotation: this.rotation,
                    text: this.text,
                    fontSize: this.fontSize,
                    visible: this.visible,
                    name: this.name,
                    useGradient: this.useGradient,
                    gradientColors: this.gradientColors,
                    gradientAngle: this.gradientAngle,
                    shadow: this.shadow,
                    blur: this.blur,
                    points: this.points
                };
            }

            static fromJSON(data) {
                const shape = new Shape(data.type, data.x, data.y, data);
                shape.id = data.id;
                shape.name = data.name;
                shape.visible = data.visible;
                return shape;
            }
        }

        // ============ App State ============
        const state = {
            shapes: [],
            selectedShape: null,
            currentTool: 'select',
            isDrawing: false,
            startX: 0,
            startY: 0,
            zoom: 1,
            panX: 0,
            panY: 0,
            showGrid: true,
            snapToGrid: false,
            gridSize: 20,
            history: [],
            historyIndex: -1,
            clipboard: null,
            penPoints: [],
            peer: null,
            connections: []
        };

        // ============ DOM Elements ============
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const layersList = document.getElementById('layers-list');
        const emptyState = document.getElementById('empty-state');
        const contextMenu = document.getElementById('context-menu');
        const toast = document.getElementById('toast');
        const zoomDisplay = document.getElementById('zoom-display');
        const collabModal = document.getElementById('collab-modal');

        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupEventListeners();
            setupCollaboration();
            loadFromLocalStorage(); // Load saved session
            render();
            saveHistory();

            // Auto-save every 30 seconds
            setInterval(() => {
                if (state.shapes.length > 0) {
                    localStorage.setItem('designflow-pro-autosave', JSON.stringify({
                        shapes: state.shapes.map(s => ({
                            type: s.type, x: s.x, y: s.y, width: s.width, height: s.height,
                            fillColor: s.fillColor, strokeColor: s.strokeColor, strokeWidth: s.strokeWidth,
                            opacity: s.opacity, cornerRadius: s.cornerRadius, rotation: s.rotation,
                            text: s.text, fontSize: s.fontSize, name: s.name,
                            useGradient: s.useGradient, gradientColors: s.gradientColors, gradientAngle: s.gradientAngle,
                            shadow: s.shadow, blur: s.blur, points: s.points
                        })),
                        zoom: state.zoom, showGrid: state.showGrid
                    }));
                }
            }, 30000);
        }

        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }

        // ============ Event Listeners ============
        function setupEventListeners() {
            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => setTool(btn.dataset.tool));
            });

            // Canvas events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('contextmenu', handleContextMenu);

            // Keyboard
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('click', () => contextMenu.classList.remove('show'));

            // Context menu actions
            contextMenu.querySelectorAll('.context-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleContextAction(item.dataset.action);
                    contextMenu.classList.remove('show');
                });
            });

            // Color pickers
            document.getElementById('fill-color').addEventListener('input', (e) => {
                updateFillColor(e.target.value);
            });

            document.getElementById('stroke-color').addEventListener('input', (e) => {
                updateStrokeColor(e.target.value);
            });

            // Property inputs
            setupPropertyListeners();

            // Toolbar buttons
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('redo-btn').addEventListener('click', redo);
            document.getElementById('zoom-in').addEventListener('click', () => zoom(0.1));
            document.getElementById('zoom-out').addEventListener('click', () => zoom(-0.1));
            document.getElementById('grid-btn').addEventListener('click', toggleGrid);
            document.getElementById('snap-btn').addEventListener('click', toggleSnap);
            document.getElementById('export-btn').addEventListener('click', exportPNG);

            // Collaboration
            document.getElementById('collab-btn').addEventListener('click', () => collabModal.classList.add('show'));
            document.getElementById('close-modal').addEventListener('click', () => collabModal.classList.remove('show'));
            document.getElementById('copy-id-btn').addEventListener('click', copyPeerId);
            document.getElementById('connect-btn').addEventListener('click', connectToPeer);

            // Effects toggles
            document.getElementById('shadow-toggle').addEventListener('click', toggleShadow);
            document.getElementById('blur-toggle').addEventListener('click', toggleBlur);
            document.getElementById('gradient-toggle').addEventListener('change', toggleGradient);

            // Gradient presets
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => applyGradientPreset(btn.dataset.preset));
            });
        }

        function setupPropertyListeners() {
            const propInputs = ['prop-x', 'prop-y', 'prop-w', 'prop-h'];
            propInputs.forEach(id => {
                document.getElementById(id).addEventListener('change', updateShapeFromProps);
            });

            // Sliders
            const sliders = [
                { id: 'rotation', valId: 'rotation-val', suffix: 'Â°', prop: 'rotation' },
                { id: 'stroke-width', valId: 'stroke-width-val', suffix: 'px', prop: 'strokeWidth' },
                { id: 'opacity', valId: 'opacity-val', suffix: '%', prop: 'opacity', scale: 0.01 },
                { id: 'corner-radius', valId: 'corner-val', suffix: 'px', prop: 'cornerRadius' },
                { id: 'shadow-blur', valId: 'shadow-blur-val', suffix: 'px' },
                { id: 'blur-amount', valId: 'blur-val', suffix: 'px' }
            ];

            sliders.forEach(s => {
                const slider = document.getElementById(s.id);
                const val = document.getElementById(s.valId);
                slider.addEventListener('input', () => {
                    val.textContent = slider.value + s.suffix;
                    if (state.selectedShape && s.prop) {
                        const value = s.scale ? parseFloat(slider.value) * s.scale : parseFloat(slider.value);
                        state.selectedShape[s.prop] = value;
                        render();
                        broadcast();
                    }
                });
                slider.addEventListener('change', saveHistory);
            });

            // Color inputs
            ['fill-hex', 'stroke-hex'].forEach(id => {
                document.getElementById(id).addEventListener('change', (e) => {
                    if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                        if (id === 'fill-hex') updateFillColor(e.target.value);
                        else updateStrokeColor(e.target.value);
                    }
                });
            });

            // Gradient colors
            ['grad-color-1', 'grad-color-2'].forEach((id, index) => {
                document.getElementById(id).addEventListener('input', (e) => {
                    if (state.selectedShape) {
                        state.selectedShape.gradientColors[index] = e.target.value;
                        updateGradientPreview();
                        render();
                        broadcast();
                    }
                });
            });

            // Color previews
            document.getElementById('fill-preview').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'color';
                input.value = document.getElementById('fill-hex').value;
                input.addEventListener('input', (e) => updateFillColor(e.target.value));
                input.click();
            });

            document.getElementById('stroke-preview').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'color';
                input.value = document.getElementById('stroke-hex').value;
                input.addEventListener('input', (e) => updateStrokeColor(e.target.value));
                input.click();
            });
        }

        // ============ Tool & Drawing ============
        function setTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left - state.panX) / state.zoom;
            let y = (e.clientY - rect.top - state.panY) / state.zoom;

            if (state.snapToGrid) {
                x = Math.round(x / state.gridSize) * state.gridSize;
                y = Math.round(y / state.gridSize) * state.gridSize;
            }

            state.startX = x;
            state.startY = y;

            if (state.currentTool === 'select') {
                state.selectedShape = null;
                for (let i = state.shapes.length - 1; i >= 0; i--) {
                    if (state.shapes[i].containsPoint(x, y)) {
                        state.selectedShape = state.shapes[i];
                        state.isDrawing = true;
                        break;
                    }
                }
                updateProperties();
                updateLayers();
                render();
            } else if (state.currentTool === 'pen' || state.currentTool === 'pencil') {
                state.isDrawing = true;
                state.penPoints = [{ x, y }];
            } else {
                state.isDrawing = true;
            }
        }

        function handleMouseMove(e) {
            if (!state.isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left - state.panX) / state.zoom;
            let y = (e.clientY - rect.top - state.panY) / state.zoom;

            if (state.currentTool === 'select' && state.selectedShape) {
                const dx = x - state.startX;
                const dy = y - state.startY;
                state.selectedShape.x += dx;
                state.selectedShape.y += dy;
                state.startX = x;
                state.startY = y;
                updateProperties();
                render();
                broadcast();
            } else if (state.currentTool === 'pen' || state.currentTool === 'pencil') {
                state.penPoints.push({ x, y });
                renderPenPreview();
            }
        }

        function handleMouseUp(e) {
            if (!state.isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - state.panX) / state.zoom;
            const y = (e.clientY - rect.top - state.panY) / state.zoom;

            if (state.currentTool === 'pen' || state.currentTool === 'pencil') {
                if (state.penPoints.length >= 2) {
                    const bounds = getPenBounds();
                    const shape = new Shape(state.currentTool, bounds.minX, bounds.minY, {
                        width: bounds.maxX - bounds.minX || 10,
                        height: bounds.maxY - bounds.minY || 10,
                        strokeColor: document.getElementById('stroke-color').value,
                        strokeWidth: parseInt(document.getElementById('stroke-width').value),
                        points: [...state.penPoints]
                    });
                    state.shapes.push(shape);
                    state.selectedShape = shape;
                    updateLayers();
                    saveHistory();
                    broadcast();
                }
                state.penPoints = [];
            } else if (state.currentTool !== 'select') {
                const width = Math.abs(x - state.startX);
                const height = Math.abs(y - state.startY);
                const startX = Math.min(state.startX, x);
                const startY = Math.min(state.startY, y);

                if (width > 5 || height > 5) {
                    const shape = new Shape(state.currentTool, startX, startY, {
                        width: width || 100,
                        height: height || 100,
                        fillColor: document.getElementById('fill-color').value,
                        strokeColor: document.getElementById('stroke-color').value,
                        strokeWidth: parseInt(document.getElementById('stroke-width').value)
                    });
                    state.shapes.push(shape);
                    state.selectedShape = shape;
                    updateProperties();
                    updateLayers();
                    saveHistory();
                    broadcast();
                }
            } else if (state.selectedShape) {
                saveHistory();
                broadcast();
            }

            state.isDrawing = false;
            render();
        }

        function getPenBounds() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.penPoints.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            return { minX, minY, maxX, maxY };
        }

        function renderPenPreview() {
            render();
            if (state.penPoints.length < 2) return;

            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);

            ctx.beginPath();
            ctx.moveTo(state.penPoints[0].x, state.penPoints[0].y);
            for (let i = 1; i < state.penPoints.length; i++) {
                ctx.lineTo(state.penPoints[i].x, state.penPoints[i].y);
            }
            ctx.strokeStyle = document.getElementById('stroke-color').value;
            ctx.lineWidth = parseInt(document.getElementById('stroke-width').value);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            ctx.restore();
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoom(delta);
        }

        function handleContextMenu(e) {
            e.preventDefault();
            if (state.selectedShape) {
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.classList.add('show');
            }
        }

        function handleKeyDown(e) {
            if (e.target.tagName === 'INPUT') return;

            if (!e.ctrlKey && !e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'v': setTool('select'); break;
                    case 'r': setTool('rectangle'); break;
                    case 'c': setTool('circle'); break;
                    case 't': setTool('triangle'); break;
                    case 'l': setTool('line'); break;
                    case 'x': setTool('text'); break;
                    case 'p': setTool('pen'); break;
                    case 'b': setTool('pencil'); break;
                    case 's': setTool('star'); break;
                    case 'h': setTool('hexagon'); break;
                    case 'a': setTool('arrow'); break;
                    case 'g': toggleGrid(); break;
                }
            }

            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();

            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'z':
                        e.preventDefault();
                        e.shiftKey ? redo() : undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 'c':
                        if (state.selectedShape) {
                            state.clipboard = state.selectedShape.clone();
                            showToast('Copied!');
                        }
                        break;
                    case 'v':
                        if (state.clipboard) {
                            e.preventDefault();
                            const pasted = state.clipboard.clone();
                            state.shapes.push(pasted);
                            state.selectedShape = pasted;
                            updateLayers();
                            saveHistory();
                            broadcast();
                            render();
                        }
                        break;
                    case 'd':
                        e.preventDefault();
                        duplicateSelected();
                        break;
                    case 'g':
                        e.preventDefault();
                        // Group (placeholder)
                        showToast('Grouping coming soon!');
                        break;
                }
            }

            if (e.key === '=' || e.key === '+') zoom(0.1);
            if (e.key === '-') zoom(-0.1);
            if (e.key === '0') { state.zoom = 1; zoomDisplay.textContent = '100%'; render(); }
            if (e.key === '?') openModal('shortcuts-modal');

            // Ctrl+S: Save
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault();
                saveToLocalStorage();
            }
        }

        // Modal functions
        function openModal(id) {
            document.getElementById(id).style.display = 'flex';
        }

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
        }

        // LocalStorage save/load
        function saveToLocalStorage() {
            const data = {
                shapes: state.shapes.map(s => ({
                    type: s.type, x: s.x, y: s.y, width: s.width, height: s.height,
                    fillColor: s.fillColor, strokeColor: s.strokeColor, strokeWidth: s.strokeWidth,
                    opacity: s.opacity, cornerRadius: s.cornerRadius, rotation: s.rotation,
                    text: s.text, fontSize: s.fontSize, name: s.name,
                    useGradient: s.useGradient, gradientColors: s.gradientColors, gradientAngle: s.gradientAngle,
                    shadow: s.shadow, blur: s.blur, points: s.points
                })),
                zoom: state.zoom,
                showGrid: state.showGrid
            };
            localStorage.setItem('designflow-pro-save', JSON.stringify(data));
            showToast('Saved!');
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('designflow-pro-save');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    state.shapes = data.shapes.map(s => new Shape(s.type, s.x, s.y, s));
                    state.zoom = data.zoom || 1;
                    state.showGrid = data.showGrid ?? true;
                    zoomDisplay.textContent = Math.round(state.zoom * 100) + '%';
                    updateLayers();
                    render();
                    showToast('Loaded previous session');
                } catch (e) {
                    console.error('Load error:', e);
                }
            }
        }

        function handleContextAction(action) {
            switch (action) {
                case 'duplicate': duplicateSelected(); break;
                case 'copy':
                    if (state.selectedShape) {
                        state.clipboard = state.selectedShape.clone();
                        showToast('Copied!');
                    }
                    break;
                case 'paste':
                    if (state.clipboard) {
                        const pasted = state.clipboard.clone();
                        state.shapes.push(pasted);
                        state.selectedShape = pasted;
                        updateLayers();
                        saveHistory();
                        broadcast();
                        render();
                    }
                    break;
                case 'front': bringToFront(); break;
                case 'back': sendToBack(); break;
                case 'delete': deleteSelected(); break;
                case 'group': showToast('Grouping coming soon!'); break;
                case 'ungroup': showToast('Ungrouping coming soon!'); break;
            }
        }

        // ============ Rendering ============
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(state.panX, state.panY);
            ctx.scale(state.zoom, state.zoom);

            if (state.showGrid) drawGrid();
            state.shapes.forEach(shape => shape.draw(ctx));
            if (state.selectedShape) drawSelection(state.selectedShape);

            ctx.restore();

            emptyState.style.display = state.shapes.length === 0 ? 'block' : 'none';
        }

        function drawGrid() {
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 0.5;

            const startX = Math.floor(-state.panX / state.zoom / state.gridSize) * state.gridSize;
            const startY = Math.floor(-state.panY / state.zoom / state.gridSize) * state.gridSize;
            const endX = startX + canvas.width / state.zoom + state.gridSize;
            const endY = startY + canvas.height / state.zoom + state.gridSize;

            ctx.beginPath();
            for (let x = startX; x < endX; x += state.gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
            }
            for (let y = startY; y < endY; y += state.gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
            }
            ctx.stroke();
        }

        function drawSelection(shape) {
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 2 / state.zoom;
            ctx.setLineDash([6 / state.zoom, 4 / state.zoom]);
            ctx.strokeRect(shape.x - 3, shape.y - 3, shape.width + 6, shape.height + 6);
            ctx.setLineDash([]);

            const handleSize = 10 / state.zoom;
            ctx.fillStyle = '#7c3aed';
            const handles = [
                { x: shape.x - handleSize / 2, y: shape.y - handleSize / 2 },
                { x: shape.x + shape.width - handleSize / 2, y: shape.y - handleSize / 2 },
                { x: shape.x - handleSize / 2, y: shape.y + shape.height - handleSize / 2 },
                { x: shape.x + shape.width - handleSize / 2, y: shape.y + shape.height - handleSize / 2 }
            ];
            handles.forEach(h => {
                ctx.fillRect(h.x, h.y, handleSize, handleSize);
            });
        }

        // ============ Property Updates ============
        function updateFillColor(color) {
            document.getElementById('fill-hex').value = color;
            document.getElementById('fill-preview').style.background = color;
            document.getElementById('fill-color').value = color;
            if (state.selectedShape) {
                state.selectedShape.fillColor = color;
                render();
                broadcast();
                saveHistory();
            }
        }

        function updateStrokeColor(color) {
            document.getElementById('stroke-hex').value = color;
            document.getElementById('stroke-preview').style.background = color;
            document.getElementById('stroke-color').value = color;
            if (state.selectedShape) {
                state.selectedShape.strokeColor = color;
                render();
                broadcast();
                saveHistory();
            }
        }

        function updateProperties() {
            if (state.selectedShape) {
                const s = state.selectedShape;
                document.getElementById('prop-x').value = Math.round(s.x);
                document.getElementById('prop-y').value = Math.round(s.y);
                document.getElementById('prop-w').value = Math.round(s.width);
                document.getElementById('prop-h').value = Math.round(s.height);
                document.getElementById('fill-hex').value = s.fillColor;
                document.getElementById('fill-preview').style.background = s.fillColor;
                document.getElementById('fill-color').value = s.fillColor;
                document.getElementById('stroke-hex').value = s.strokeColor;
                document.getElementById('stroke-preview').style.background = s.strokeColor;
                document.getElementById('stroke-color').value = s.strokeColor;
                document.getElementById('stroke-width').value = s.strokeWidth;
                document.getElementById('stroke-width-val').textContent = s.strokeWidth + 'px';
                document.getElementById('rotation').value = s.rotation;
                document.getElementById('rotation-val').textContent = s.rotation + 'Â°';
                document.getElementById('opacity').value = s.opacity * 100;
                document.getElementById('opacity-val').textContent = Math.round(s.opacity * 100) + '%';
                document.getElementById('corner-radius').value = s.cornerRadius;
                document.getElementById('corner-val').textContent = s.cornerRadius + 'px';
                document.getElementById('gradient-toggle').checked = s.useGradient;
                document.getElementById('gradient-controls').style.display = s.useGradient ? 'block' : 'none';
                if (s.gradientColors.length >= 2) {
                    document.getElementById('grad-color-1').value = s.gradientColors[0];
                    document.getElementById('grad-color-2').value = s.gradientColors[1];
                }
                updateGradientPreview();

                // Effects
                document.getElementById('shadow-toggle').classList.toggle('active', s.shadow.enabled);
                document.getElementById('shadow-controls').style.display = s.shadow.enabled ? 'block' : 'none';
                document.getElementById('blur-toggle').classList.toggle('active', s.blur.enabled);
                document.getElementById('blur-controls').style.display = s.blur.enabled ? 'block' : 'none';
            }
        }

        function updateShapeFromProps() {
            if (state.selectedShape) {
                state.selectedShape.x = parseFloat(document.getElementById('prop-x').value) || 0;
                state.selectedShape.y = parseFloat(document.getElementById('prop-y').value) || 0;
                state.selectedShape.width = parseFloat(document.getElementById('prop-w').value) || 1;
                state.selectedShape.height = parseFloat(document.getElementById('prop-h').value) || 1;
                render();
                broadcast();
                saveHistory();
            }
        }

        function updateGradientPreview() {
            if (state.selectedShape && state.selectedShape.gradientColors.length >= 2) {
                const colors = state.selectedShape.gradientColors;
                document.getElementById('gradient-preview').style.background =
                    `linear-gradient(135deg, ${colors[0]}, ${colors[1]})`;
            }
        }

        // ============ Layers ============
        function updateLayers() {
            layersList.innerHTML = '';
            [...state.shapes].reverse().forEach(shape => {
                const item = document.createElement('div');
                item.className = 'layer-item' + (shape === state.selectedShape ? ' selected' : '');
                item.innerHTML = `
                    <div class="layer-icon" style="background: ${shape.useGradient ? 'linear-gradient(135deg, ' + shape.gradientColors.join(',') + ')' : shape.fillColor}"></div>
                    <span class="layer-name">${shape.name}</span>
                `;
                item.addEventListener('click', () => {
                    state.selectedShape = shape;
                    updateProperties();
                    updateLayers();
                    render();
                });
                layersList.appendChild(item);
            });
        }

        // ============ Effects ============
        function toggleShadow() {
            if (state.selectedShape) {
                state.selectedShape.shadow.enabled = !state.selectedShape.shadow.enabled;
                document.getElementById('shadow-toggle').classList.toggle('active', state.selectedShape.shadow.enabled);
                document.getElementById('shadow-controls').style.display = state.selectedShape.shadow.enabled ? 'block' : 'none';
                render();
                broadcast();
                saveHistory();
            }
        }

        function toggleBlur() {
            if (state.selectedShape) {
                state.selectedShape.blur.enabled = !state.selectedShape.blur.enabled;
                document.getElementById('blur-toggle').classList.toggle('active', state.selectedShape.blur.enabled);
                document.getElementById('blur-controls').style.display = state.selectedShape.blur.enabled ? 'block' : 'none';
                render();
                broadcast();
                saveHistory();
            }
        }

        function toggleGradient() {
            if (state.selectedShape) {
                state.selectedShape.useGradient = document.getElementById('gradient-toggle').checked;
                document.getElementById('gradient-controls').style.display = state.selectedShape.useGradient ? 'block' : 'none';
                render();
                broadcast();
                saveHistory();
            }
        }

        function applyGradientPreset(preset) {
            if (!state.selectedShape) return;

            const presets = {
                sunset: ['#f97316', '#ec4899'],
                ocean: ['#06b6d4', '#3b82f6'],
                forest: ['#22c55e', '#14b8a6'],
                fire: ['#ef4444', '#f97316'],
                midnight: ['#6366f1', '#8b5cf6'],
                gold: ['#eab308', '#f59e0b']
            };

            if (presets[preset]) {
                state.selectedShape.gradientColors = [...presets[preset]];
                state.selectedShape.useGradient = true;
                document.getElementById('gradient-toggle').checked = true;
                document.getElementById('gradient-controls').style.display = 'block';
                document.getElementById('grad-color-1').value = presets[preset][0];
                document.getElementById('grad-color-2').value = presets[preset][1];
                updateGradientPreview();
                render();
                broadcast();
                saveHistory();
            }
        }

        // ============ Actions ============
        function deleteSelected() {
            if (state.selectedShape) {
                const index = state.shapes.indexOf(state.selectedShape);
                if (index > -1) {
                    state.shapes.splice(index, 1);
                    state.selectedShape = null;
                    updateLayers();
                    saveHistory();
                    broadcast();
                    render();
                }
            }
        }

        function duplicateSelected() {
            if (state.selectedShape) {
                const cloned = state.selectedShape.clone();
                state.shapes.push(cloned);
                state.selectedShape = cloned;
                updateLayers();
                saveHistory();
                broadcast();
                render();
            }
        }

        function bringToFront() {
            if (state.selectedShape) {
                const index = state.shapes.indexOf(state.selectedShape);
                if (index > -1) {
                    state.shapes.splice(index, 1);
                    state.shapes.push(state.selectedShape);
                    updateLayers();
                    saveHistory();
                    broadcast();
                    render();
                }
            }
        }

        function sendToBack() {
            if (state.selectedShape) {
                const index = state.shapes.indexOf(state.selectedShape);
                if (index > -1) {
                    state.shapes.splice(index, 1);
                    state.shapes.unshift(state.selectedShape);
                    updateLayers();
                    saveHistory();
                    broadcast();
                    render();
                }
            }
        }

        function zoom(delta) {
            state.zoom = Math.max(0.1, Math.min(5, state.zoom + delta));
            zoomDisplay.textContent = Math.round(state.zoom * 100) + '%';
            render();
        }

        function toggleGrid() {
            state.showGrid = !state.showGrid;
            document.getElementById('grid-btn').classList.toggle('active', state.showGrid);
            render();
        }

        function toggleSnap() {
            state.snapToGrid = !state.snapToGrid;
            document.getElementById('snap-btn').classList.toggle('active', state.snapToGrid);
            showToast(state.snapToGrid ? 'Snap enabled' : 'Snap disabled');
        }

        function exportPNG() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.shapes.forEach(s => {
                minX = Math.min(minX, s.x);
                minY = Math.min(minY, s.y);
                maxX = Math.max(maxX, s.x + s.width);
                maxY = Math.max(maxY, s.y + s.height);
            });

            if (!isFinite(minX)) {
                showToast('Nothing to export!');
                return;
            }

            const padding = 40;
            tempCanvas.width = maxX - minX + padding * 2;
            tempCanvas.height = maxY - minY + padding * 2;

            tempCtx.fillStyle = '#0f0f0f';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            tempCtx.translate(-minX + padding, -minY + padding);
            state.shapes.forEach(shape => shape.draw(tempCtx));

            const link = document.createElement('a');
            link.download = 'design.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();

            showToast('Exported as PNG!');
        }

        // ============ History ============
        function saveHistory() {
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(JSON.stringify(state.shapes.map(s => s.toJSON())));
            state.historyIndex++;
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                restoreHistory();
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                restoreHistory();
            }
        }

        function restoreHistory() {
            const data = JSON.parse(state.history[state.historyIndex]);
            state.shapes = data.map(d => Shape.fromJSON(d));
            state.selectedShape = null;
            updateLayers();
            render();
            broadcast();
        }

        // ============ Collaboration ============
        function setupCollaboration() {
            try {
                state.peer = new Peer();

                state.peer.on('open', (id) => {
                    document.getElementById('my-peer-id').value = id;
                });

                state.peer.on('connection', (conn) => {
                    setupConnection(conn);
                });

                state.peer.on('error', (err) => {
                    console.error('Peer error:', err);
                });
            } catch (e) {
                console.error('PeerJS not available:', e);
            }
        }

        function setupConnection(conn) {
            state.connections.push(conn);
            updateCollabStatus();

            conn.on('data', (data) => {
                if (data.type === 'sync') {
                    state.shapes = data.shapes.map(d => Shape.fromJSON(d));
                    state.selectedShape = null;
                    updateLayers();
                    render();
                }
            });

            conn.on('close', () => {
                state.connections = state.connections.filter(c => c !== conn);
                updateCollabStatus();
            });

            // Send current state
            conn.on('open', () => {
                conn.send({
                    type: 'sync',
                    shapes: state.shapes.map(s => s.toJSON())
                });
            });
        }

        function connectToPeer() {
            const peerId = document.getElementById('connect-peer-id').value.trim();
            if (!peerId) return;

            const conn = state.peer.connect(peerId);
            setupConnection(conn);
            collabModal.classList.remove('show');
            showToast('Connected!');
        }

        function copyPeerId() {
            const id = document.getElementById('my-peer-id').value;
            navigator.clipboard.writeText(id);
            showToast('Copied to clipboard!');
        }

        function updateCollabStatus() {
            const status = document.getElementById('collab-status');
            const count = document.getElementById('peer-count');

            if (state.connections.length > 0) {
                status.style.display = 'flex';
                count.textContent = state.connections.length + ' connected';
            } else {
                status.style.display = 'none';
            }
        }

        function broadcast() {
            const data = {
                type: 'sync',
                shapes: state.shapes.map(s => s.toJSON())
            };
            state.connections.forEach(conn => {
                if (conn.open) conn.send(data);
            });
        }

        // ============ Utils ============
        function showToast(message) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // Initialize
        init();
    </script>
</body>
</html>
